-- Baggo (Fashion) â Supabase schema
-- Run this in Supabase SQL editor.
-- Safe to run multiple times.

-- Extensions
create extension if not exists pgcrypto;

-- updated_at helper
create or replace function public.set_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at = now();
  return new;
end;
$$;

-- =====================
-- Admins (links to Supabase Auth users)
-- =====================
create table if not exists public.admins (
  user_id uuid primary key references auth.users(id) on delete cascade,
  email text unique,
  created_at timestamptz not null default now()
);

-- =====================
-- Categories (supports secret categories)
-- =====================
create table if not exists public.categories (
  id uuid primary key default gen_random_uuid(),
  slug text not null unique,
  label text not null,
  category_type text not null default 'normal' check (category_type in ('normal','secret')),
  password text null,
  visible boolean not null default true,
  sort_order int not null default 0,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.categories
  drop constraint if exists categories_secret_password_chk;
alter table public.categories
  add constraint categories_secret_password_chk
  check (
    (category_type <> 'secret')
    or (password is not null and length(trim(password)) >= 1)
  );

DROP TRIGGER IF EXISTS trg_categories_updated_at ON public.categories;
CREATE TRIGGER trg_categories_updated_at
BEFORE UPDATE ON public.categories
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- =====================
-- Products
-- =====================
create table if not exists public.products (
  id uuid primary key default gen_random_uuid(),
  name text not null,
  description text not null default '',
  category_slug text references public.categories(slug) on update cascade on delete set null,
  price numeric(12,2) not null default 0,
  featured boolean not null default false,
  visible boolean not null default true,
  images text[] not null default '{}'::text[],
  sizes text[] not null default '{}'::text[],
  stock jsonb not null default '{}'::jsonb,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

DROP TRIGGER IF EXISTS trg_products_updated_at ON public.products;
CREATE TRIGGER trg_products_updated_at
BEFORE UPDATE ON public.products
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- =====================
-- Site settings (single row: id=1)
-- =====================
create table if not exists public.site_settings (
  id int primary key,
  site_name text not null default 'Baggo',

  banner_enabled boolean not null default true,
  banner_text text not null default 'This is Baggo',
  banner_button_label text not null default '',
  banner_button_href text not null default '',

  hero_badge_text text not null default 'New drop - Minimal, premium pieces',
  hero_title text not null default 'Carry better. Shop Baggo.',
  hero_subtitle text not null default 'A clean storefront built for speed now - and a Pro-ready admin later.',

  hero_primary_cta_label text not null default 'Shop now',
  hero_primary_cta_href text not null default '/shop',
  hero_secondary_cta_label text not null default 'Explore bags',
  hero_secondary_cta_href text not null default '/shop?category=bags',

  hero_main_product_id uuid null,
  hero_side_product_id uuid null,

  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

DROP TRIGGER IF EXISTS trg_site_settings_updated_at ON public.site_settings;
CREATE TRIGGER trg_site_settings_updated_at
BEFORE UPDATE ON public.site_settings
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

INSERT INTO public.site_settings (id)
VALUES (1)
ON CONFLICT (id) DO NOTHING;

-- =====================
-- Website settings (business profile / WhatsApp)
-- =====================
create table if not exists public.website_settings (
  id bigint generated by default as identity primary key,
  site_name text not null default 'Baggo',
  whatsapp text not null default '',
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

DROP TRIGGER IF EXISTS trg_website_settings_updated_at ON public.website_settings;
CREATE TRIGGER trg_website_settings_updated_at
BEFORE UPDATE ON public.website_settings
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

-- Seed one row if empty (StoreContext reads maybeSingle())
INSERT INTO public.website_settings (site_name, whatsapp)
SELECT 'Baggo', ''
WHERE NOT EXISTS (SELECT 1 FROM public.website_settings);

-- =====================
-- Fashion homepage (heroes + quads)
-- =====================
create table if not exists public.heroes (
  id uuid primary key default gen_random_uuid(),
  title text not null default '',
  subtitle text not null default '',
  image_url text not null,
  position int not null default 0,
  is_active boolean not null default true,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

DROP TRIGGER IF EXISTS trg_heroes_updated_at ON public.heroes;
CREATE TRIGGER trg_heroes_updated_at
BEFORE UPDATE ON public.heroes
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

create table if not exists public.hero_quads (
  id uuid primary key default gen_random_uuid(),
  hero_id uuid not null references public.heroes(id) on delete cascade,
  position int not null check (position between 1 and 4),
  quad_type text not null default 'editorial' check (quad_type in ('category','product','editorial')),
  title text not null default '',
  image_url text not null default '',
  category_id uuid null references public.categories(id) on delete set null,
  product_id uuid null references public.products(id) on delete set null,
  product_mode text null check (product_mode in ('auto','manual')),
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now(),
  unique (hero_id, position)
);

ALTER TABLE public.hero_quads
  DROP CONSTRAINT IF EXISTS hero_quads_payload_chk;
ALTER TABLE public.hero_quads
  ADD CONSTRAINT hero_quads_payload_chk
  CHECK (
    (quad_type = 'product' and product_id is not null)
    or (quad_type = 'editorial' and category_id is not null and length(trim(image_url)) >= 1)
    or (quad_type = 'category' and category_id is not null)
  );

ALTER TABLE public.hero_quads
  DROP CONSTRAINT IF EXISTS hero_quads_product_mode_chk;
ALTER TABLE public.hero_quads
  ADD CONSTRAINT hero_quads_product_mode_chk
  CHECK (product_mode is null or quad_type = 'category');

DROP TRIGGER IF EXISTS trg_hero_quads_updated_at ON public.hero_quads;
CREATE TRIGGER trg_hero_quads_updated_at
BEFORE UPDATE ON public.hero_quads
FOR EACH ROW EXECUTE FUNCTION public.set_updated_at();

create table if not exists public.hero_quad_products (
  hero_quad_id uuid not null references public.hero_quads(id) on delete cascade,
  product_id uuid not null references public.products(id) on delete cascade,
  position int not null default 1,
  created_at timestamptz not null default now(),
  primary key (hero_quad_id, product_id)
);

CREATE INDEX IF NOT EXISTS hero_quad_products_quad_idx ON public.hero_quad_products (hero_quad_id, position);

-- =====================
-- Helper: is_admin
-- =====================
create or replace function public.is_admin(uid uuid)
returns boolean
language sql
stable
as $$
  select exists(
    select 1 from public.admins a where a.user_id = uid
  );
$$;

-- Optional helper for secret categories (used by the frontend)
create or replace function public.check_category_password(slug_in text, password_in text)
returns boolean
language plpgsql
security definer
set search_path = public
as $$
declare
  ctype text;
  pw text;
begin
  select category_type, password into ctype, pw
  from public.categories
  where slug = slug_in;

  if ctype is distinct from 'secret' then
    return false;
  end if;
  if pw is null then
    return false;
  end if;
  return pw = password_in;
end;
$$;

GRANT EXECUTE ON FUNCTION public.check_category_password(text, text) TO anon, authenticated;

-- =====================
-- Row Level Security
-- =====================
ALTER TABLE public.admins ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.site_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.website_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.heroes ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.hero_quads ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.hero_quad_products ENABLE ROW LEVEL SECURITY;

-- Public read (storefront)
DROP POLICY IF EXISTS "Public read categories" ON public.categories;
CREATE POLICY "Public read categories" ON public.categories
FOR SELECT TO public
USING (true);

DROP POLICY IF EXISTS "Public read products" ON public.products;
CREATE POLICY "Public read products" ON public.products
FOR SELECT TO public
USING (true);

DROP POLICY IF EXISTS "Public read site settings" ON public.site_settings;
CREATE POLICY "Public read site settings" ON public.site_settings
FOR SELECT TO public
USING (true);

DROP POLICY IF EXISTS "Public read website settings" ON public.website_settings;
CREATE POLICY "Public read website settings" ON public.website_settings
FOR SELECT TO public
USING (true);

DROP POLICY IF EXISTS "Public read heroes" ON public.heroes;
CREATE POLICY "Public read heroes" ON public.heroes
FOR SELECT TO public
USING (true);

DROP POLICY IF EXISTS "Public read hero quads" ON public.hero_quads;
CREATE POLICY "Public read hero quads" ON public.hero_quads
FOR SELECT TO public
USING (true);

DROP POLICY IF EXISTS "Public read hero quad products" ON public.hero_quad_products;
CREATE POLICY "Public read hero quad products" ON public.hero_quad_products
FOR SELECT TO public
USING (true);

-- Admins table: users can read their own row (so the app can check admin access)
DROP POLICY IF EXISTS "Read own admin row" ON public.admins;
CREATE POLICY "Read own admin row" ON public.admins
FOR SELECT TO authenticated
USING (user_id = auth.uid());

-- Admin write policies (authenticated admin users only)
DROP POLICY IF EXISTS "Admins manage categories" ON public.categories;
CREATE POLICY "Admins manage categories" ON public.categories
FOR ALL TO authenticated
USING (public.is_admin(auth.uid()))
WITH CHECK (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Admins manage products" ON public.products;
CREATE POLICY "Admins manage products" ON public.products
FOR ALL TO authenticated
USING (public.is_admin(auth.uid()))
WITH CHECK (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Admins manage site settings" ON public.site_settings;
CREATE POLICY "Admins manage site settings" ON public.site_settings
FOR ALL TO authenticated
USING (public.is_admin(auth.uid()))
WITH CHECK (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Admins manage website settings" ON public.website_settings;
CREATE POLICY "Admins manage website settings" ON public.website_settings
FOR ALL TO authenticated
USING (public.is_admin(auth.uid()))
WITH CHECK (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Admins manage heroes" ON public.heroes;
CREATE POLICY "Admins manage heroes" ON public.heroes
FOR ALL TO authenticated
USING (public.is_admin(auth.uid()))
WITH CHECK (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Admins manage hero quads" ON public.hero_quads;
CREATE POLICY "Admins manage hero quads" ON public.hero_quads
FOR ALL TO authenticated
USING (public.is_admin(auth.uid()))
WITH CHECK (public.is_admin(auth.uid()));

DROP POLICY IF EXISTS "Admins manage hero quad products" ON public.hero_quad_products;
CREATE POLICY "Admins manage hero quad products" ON public.hero_quad_products
FOR ALL TO authenticated
USING (public.is_admin(auth.uid()))
WITH CHECK (public.is_admin(auth.uid()));

-- Admins table: only admins can manage admins
-- (Bootstrap your first admin by inserting in SQL editor, which bypasses RLS)
DROP POLICY IF EXISTS "Admins manage admins" ON public.admins;
CREATE POLICY "Admins manage admins" ON public.admins
FOR ALL TO authenticated
USING (public.is_admin(auth.uid()))
WITH CHECK (public.is_admin(auth.uid()));

-- =====================
-- Seed demo categories
-- =====================
INSERT INTO public.categories (slug, label, visible, sort_order, category_type, password)
VALUES
  ('bags', 'Bags', true, 0, 'normal', null),
  ('accessories', 'Accessories', true, 1, 'normal', null)
ON CONFLICT (slug) DO UPDATE SET
  label = excluded.label,
  visible = excluded.visible,
  sort_order = excluded.sort_order,
  category_type = excluded.category_type,
  password = excluded.password;

-- Bootstrap your first admin (run AFTER creating an auth user)
-- insert into public.admins (user_id, email) values ('<AUTH_USER_UUID>', '<EMAIL>');
